<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SuperLuis.app</title>
<style>
:root{
  --bg:#0f172a; --panel:#111827; --card:#1e293b; --ink:#e5e7eb; --muted:#94a3b8;
  --ok:#10b981; --ok2:#065f46; --warn:#fbbf24; --border:#334155; --accent:#60a5fa;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Roboto,Arial}
header{position:sticky;top:0;padding:10px;background:var(--panel);border-bottom:1px solid var(--border);z-index:20}
h1{margin:0;font-size:18px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
button{border:0;border-radius:10px;padding:8px 12px;background:#334155;color:#fff}
button.primary{background:var(--ok);color:#052e27}
button.ghost{background:transparent;border:1px solid var(--border)}
button.warn{background:var(--warn);color:#111}
.badge{color:var(--muted);font-size:14px}
main{padding:12px;padding-bottom:96px}
.exercise{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;margin-bottom:14px}
.exercise.done{background:var(--ok2)}
.exercise h3{margin:0 0 6px 0;font-size:16px}
.seriesItem{border:1px dashed var(--border);border-radius:12px;background:#0b1322;padding:10px;margin-top:10px}
.seriesItem.editable{outline:2px solid var(--accent)}
.seriesItem.running{background:#0f3b2f;outline:2px solid var(--ok)}
.ctrls{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
.chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);
  border-radius:999px;padding:4px 8px;background:#0b1322}
.value{min-width:32px;display:inline-block;text-align:center}
.muted{color:var(--muted)}
/* Barra descanso fija */
#restBar{position:sticky;top:56px;display:none;background:var(--warn);color:#111;
  padding:10px;border-bottom:1px solid #000;z-index:15}
/* HUD serie en curso */
#hud{position:fixed;left:0;right:0;bottom:0;background:rgba(17,24,39,.92);
  border-top:1px solid var(--border);padding:10px 12px;display:none;z-index:25}
#hud .title{font-weight:700}
#hud .big{font-size:28px;line-height:1.1;margin-top:6px}
#hud .sub{color:var(--muted);font-size:13px}
#snack{position:fixed;left:50%;transform:translateX(-50%);bottom:88px;background:#000c;
  color:#fff;padding:8px 12px;border-radius:8px;display:none;z-index:40}
/* Overlay audio */
#unlock{position:fixed;inset:0;background:#000a;display:flex;align-items:center;justify-content:center;z-index:50}
#unlock .box{background:#0b1220;border:1px solid var(--border);border-radius:14px;padding:18px;max-width:360px}
</style>
</head>
<body>
<header>
  <div class="row">
    <h1>SuperLuis.app</h1>
    <label class="badge">Auto-siguiente serie
      <input id="autoNext" type="checkbox" checked>
    </label>
    <button id="btnStartDay" class="primary">Empezar ejercicio</button>
    <button id="btnSave" class="ghost">Guardar</button>
    <button id="btnResetDay" class="ghost">Reset día</button>
  </div>
</header>

<div id="restBar"></div>
<main id="app"></main>

<!-- HUD de serie en curso -->
<div id="hud">
  <div class="title" id="hudTitle">Serie</div>
  <div class="big" id="hudCount">—</div>
  <div class="sub" id="hudHint">Cuenta de repeticiones y voz</div>
</div>

<div id="snack"></div>

<!-- Desbloqueo de audio/voz -->
<div id="unlock">
  <div class="box">
    <h3 style="margin:0 0 6px 0">Activar audio</h3>
    <p class="muted" style="margin:0 0 12px 0">Pulsa para habilitar sonidos y voz (requisito de Android).</p>
    <div class="row">
      <button id="btnUnlock" class="primary">Activar</button>
    </div>
  </div>
</div>

<script>
/* ========== Estado inicial ========== */
const initRoutine = [{
  name:"Seated Chest Press", machine:"L070", rest:20,
  planned:[{reps:10,weight:57},{reps:10,weight:57},{reps:10,weight:57}],
  performed:[], done:false
},{
  name:"Seated Row", machine:"L090", rest:20,
  planned:[{reps:6,weight:70},{reps:6,weight:70},{reps:6,weight:70}],
  performed:[], done:false
}];

const state = {
  routine: JSON.parse(localStorage.getItem("sl_routine")||"null") || initRoutine,
  current: { phase:"idle", exIdx:null, sIdx:null, restLeft:0, paused:false, cadence:2000 },
  audioReady:false,
  autoNext: JSON.parse(localStorage.getItem("sl_autoNext")||"true")
};

function persist(){
  localStorage.setItem("sl_routine", JSON.stringify(state.routine));
  localStorage.setItem("sl_autoNext", state.autoNext);
}

/* ========== Audio / Voz ========== */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let actx=null;
function ensureAudio(){
  if(!actx){ actx = new AudioCtx(); }
  if(actx.state==="suspended"){ actx.resume(); }
  state.audioReady = true;
  document.getElementById('unlock').style.display="none";
}

async function beep(freq=880,ms=120){
  if(!state.audioReady) return;
  const o=actx.createOscillator(), g=actx.createGain();
  o.frequency.value=freq; g.gain.value=0.08; // volumen bajo
  o.connect(g); g.connect(actx.destination); o.start(); await wait(ms); o.stop();
}

function speak(text, max=2500){
  // No bloquea el flujo si TTS no disponible
  if(!state.audioReady || !("speechSynthesis" in window)) return Promise.resolve();
  try { speechSynthesis.cancel(); } catch(e){}
  return new Promise(res=>{
    const u = new SpeechSynthesisUtterance(text);
    u.lang="es-ES";
    let done=false;
    const to = setTimeout(()=>{ if(!done){ done=true; res(); } }, max);
    u.onend=()=>{ if(!done){ done=true; clearTimeout(to); res(); } };
    speechSynthesis.speak(u);
  });
}

/* ========== Utiles ========== */
const $ = s=>document.querySelector(s);
function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
function snack(msg){ const n=$("#snack"); n.textContent=msg; n.style.display="block"; setTimeout(()=>n.style.display="none",1500); }

/* ========== Render ========== */
function render(){
  const app=$("#app"); app.innerHTML="";
  state.routine.forEach((ex,ei)=>{
    const done = ex.performed.length>=ex.planned.length;
    const sec = document.createElement("section");
    sec.className="exercise"+(done?" done":"");
    sec.dataset.ei = ei;
    sec.innerHTML = `
      <h3>${ex.name} <small class="muted">(${ex.machine})</small></h3>
      <div class="muted">Completadas: ${ex.performed.length}/${ex.planned.length} · Descanso ${ex.rest}s</div>
      <div class="seriesWrap"></div>
      <div class="row" style="margin-top:8px">
        <button class="primary" data-act="startExercise">Empezar ejercicio</button>
        <button class="ghost" data-act="addSeries">+ serie</button>
      </div>
      <div class="muted" style="margin-top:8px">Historial: ${ex.performed.map(s=>`${s.reps}×${s.weight}kg`).join(" · ")||"—"}</div>
    `;
    // Solo mostrar la serie pendiente (editable)
    if(!done){
      const si = ex.performed.length;
      const last = ex.performed[si-1];
      const base = last ? {...last} : ex.planned[si];
      const wrap = sec.querySelector(".seriesWrap");
      const item = document.createElement("div");
      item.className="seriesItem editable";
      item.dataset.si = si;
      item.innerHTML = `
        <b>Serie ${si+1}</b>
        <div class="ctrls">
          <span class="chip">Reps:
            <button data-act="rep-" class="ghost">-</button>
            <span data-val="reps" class="value">${base.reps}</span>
            <button data-act="rep+" class="ghost">+</button>
          </span>
          <span class="chip">Peso:
            <button data-act="w-" class="ghost">-0.5</button>
            <span data-val="weight" class="value">${(+base.weight).toFixed(1)}</span>
            <button data-act="w+" class="ghost">+0.5</button>
          </span>
          <button class="primary" data-act="startSeries">Iniciar serie</button>
        </div>
      `;
      wrap.appendChild(item);
    }
    app.appendChild(sec);
  });
  updateRestBar();
}
function updateRestBar(){
  const bar=$("#restBar");
  if(state.current.phase!=="rest"){ bar.style.display="none"; bar.innerHTML=""; return; }
  bar.style.display="block";
  bar.innerHTML = `
    Descanso: ${state.current.restLeft}s
    <button data-act="pauseRest">${state.current.paused?"Continuar":"Pausa"}</button>
    <button data-act="skipRest" class="warn">Saltar</button>
  `;
}

/* ========== HUD Serie ========== */
function hudShow(exName, reps, current){
  $("#hudTitle").textContent = exName;
  $("#hudCount").textContent = `Reps: ${current}/${reps}`;
  $("#hud").style.display="block";
}
function hudUpdate(reps, current){
  $("#hudCount").textContent = `Reps: ${current}/${reps}`;
}
function hudHide(){ $("#hud").style.display="none"; }

/* ========== Lógica de serie (sin cuelgues) ========== */
async function runSeries(ei, si, reps, weight){
  // Visual inmediato para que "se note" que arranca
  const ex = state.routine[ei];
  const card = document.querySelector(`.exercise[data-ei="${ei}"]`);
  const item = card?.querySelector(".seriesItem");
  if(item){ item.classList.remove("editable"); item.classList.add("running"); }
  hudShow(`${ex.name} (${ex.machine})`, reps, 0);
  // Confirmación inmediata
  await beep(900,90);
  await speak(`Empezamos serie ${si+1}`);

  state.current = { ...state.current, phase:"series", exIdx:ei, sIdx:si };

  // Cadencia por rep (2s): número, "arriba", "abajo"
  let repNow = 0;
  for(let r=1;r<=reps;r++){
    repNow=r; hudUpdate(reps,repNow);
    // voz (no bloquea si no hay TTS)
    speak(String(r));
    await wait(700);
    speak("arriba");
    await wait(700);
    speak("abajo");
    await wait(state.current.cadence - 1400); // resto hasta 2s aprox
  }

  // Registrar como realizada la serie
  ex.performed.push({reps,weight:+weight});
  if(ex.performed.length>=ex.planned.length) ex.done=true;
  persist();

  // Fin serie → descanso
  hudHide();
  render();
  await startRest(ex.rest);

  // Auto-siguiente serie del MISMO ejercicio
  if(state.autoNext){
    const againCard = document.querySelector(`.exercise[data-ei="${ei}"]`);
    const btn = againCard?.querySelector('[data-act="startSeries"]');
    if(btn) btn.click();
  }
}

function startRest(seconds){
  return new Promise(async res=>{
    state.current.phase="rest";
    state.current.restLeft = seconds;
    state.current.paused = false;
    updateRestBar();
    await speak(`Iniciamos descanso de ${seconds} segundos`);

    async function tick(){
      if(state.current.phase!=="rest"){ updateRestBar(); return res(); }
      if(!state.current.paused){
        state.current.restLeft--;
        if([3,2,1].includes(state.current.restLeft)) beep(400+state.current.restLeft*200,120);
        updateRestBar();
        if(state.current.restLeft<=0){
          await speak("Descanso terminado");
          state.current.phase="idle"; updateRestBar();
          return res();
        }
      }
      setTimeout(tick,1000);
    }
    tick();
  });
}

/* ========== Eventos ========== */
document.addEventListener("click", (e)=>{
  const btn = e.target.closest("button"); if(!btn) return;

  if(btn.id==="btnUnlock"){ ensureAudio(); snack("Audio listo"); return; }

  if(btn.id==="btnSave"){ persist(); beep(750,100); snack("Guardado"); return; }

  if(btn.id==="btnResetDay"){
    state.routine.forEach(ex=>{ ex.performed=[]; ex.done=false; });
    persist(); render(); snack("Día reiniciado"); return;
  }

  if(btn.id==="btnStartDay"){
    // Busca el primer ejercicio pendiente y arranca su serie
    ensureAudio();
    const idx = state.routine.findIndex(x=>x.performed.length < x.planned.length);
    if(idx>=0){
      const b = document.querySelector(`.exercise[data-ei="${idx}"] [data-act="startSeries"]`);
      if(b){ b.click(); } else { snack("No hay series para iniciar"); }
    } else {
      snack("Todo completado 👏");
    }
    return;
  }

  const act = btn.dataset.act;
  if(!act) return;

  // Clics dentro de un ejercicio
  const card = e.target.closest(".exercise");
  if(!card) return;
  const ei = +card.dataset.ei;
  const ex = state.routine[ei];
  const item = card.querySelector(".seriesItem");
  const repsEl = item?.querySelector('[data-val="reps"]');
  const wEl = item?.querySelector('[data-val="weight"]');

  if(act==="rep-"){ repsEl.textContent = Math.max(1, +repsEl.textContent - 1); }
  if(act==="rep+"){ repsEl.textContent = +repsEl.textContent + 1; }
  if(act==="w-"){ wEl.textContent = (+wEl.textContent - 0.5).toFixed(1); }
  if(act==="w+"){ wEl.textContent = (+wEl.textContent + 0.5).toFixed(1); }

  if(act==="addSeries"){
    // Añade una serie al plan (editable en siguiente vuelta)
    const base = ex.planned[ex.planned.length-1] || {reps:10,weight: (ex.performed[0]?.weight||50) };
    ex.planned.push({ ...base });
    persist(); render(); snack("+1 serie");
  }

  if(act==="startExercise"){
    // Equivalente a pulsar Iniciar serie (primera pendiente)
    const b = card.querySelector('[data-act="startSeries"]');
    if(b) b.click(); else snack("Ejercicio ya completado");
  }

  if(act==="startSeries"){
    ensureAudio();
    if(!item){ snack("Sin serie pendiente"); return; }
    // Bloquea edición durante la serie
    item.classList.remove("editable"); item.classList.add("running");
    const si = ex.performed.length;
    const reps = +repsEl.textContent;
    const weight = +wEl.textContent;
    runSeries(ei, si, reps, weight);
  }

  if(act==="pauseRest"){
    state.current.paused = !state.current.paused;
    if(!state.current.paused && state.current.restLeft < 10) state.current.restLeft = 10;
    updateRestBar();
  }

  if(act==="skipRest"){
    // Saltar descanso → continuar con siguiente serie del MISMO ejercicio
    state.current.phase="idle"; updateRestBar();
    if(state.autoNext){
      const b = card.querySelector('[data-act="startSeries"]');
      if(b) b.click();
    }
  }
});

document.getElementById('autoNext').addEventListener('change',(e)=>{
  state.autoNext = e.target.checked; persist();
});

/* ========== Inicio ========== */
render();
</script>
</body>
</html>